{"version":3,"file":"viewportUtils.js","sourceRoot":"","sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nfunction getTotalFrozenColumnWidth<R, SR>(columns: readonly CalculatedColumn<R, SR>[], lastFrozenColumnIndex: number): number {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nconst RENDER_BACTCH_SIZE = 8;\n\nexport function getVerticalRangeToRender(\n  height: number,\n  rowHeight: number,\n  scrollTop: number,\n  rowsCount: number\n) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return [rowOverscanStartIdx, rowOverscanEndIdx] as const;\n}\n\nexport interface HorizontalRangeToRenderParams<R, SR> {\n  columnMetrics: ColumnMetrics<R, SR>;\n  scrollLeft: number;\n}\n\nexport function getHorizontalRangeToRender<R, SR>({\n  columnMetrics,\n  scrollLeft\n}: HorizontalRangeToRenderParams<R, SR>): [number, number] {\n  const { columns, lastFrozenColumnIndex, viewportWidth } = columnMetrics;\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth;\n  // get first and last non-frozen column indexes\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n  // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n  if (viewportLeft >= viewportRight) {\n    return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n  }\n\n  // get the first visible non-frozen column index\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n  while (colVisibleStartIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleStartIdx];\n    // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n    if (left + width > viewportLeft) {\n      break;\n    }\n    colVisibleStartIdx++;\n  }\n\n  // get the last visible non-frozen column index\n  let colVisibleEndIdx = colVisibleStartIdx;\n  while (colVisibleEndIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleEndIdx];\n    // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n    if (left + width >= viewportRight) {\n      break;\n    }\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n  return [colOverscanStartIdx, colOverscanEndIdx];\n}\n\nexport function getViewportColumns<R, SR>(columns: readonly CalculatedColumn<R, SR>[], colOverscanStartIdx: number, colOverscanEndIdx: number) {\n  const viewportColumns: CalculatedColumn<R, SR>[] = [];\n  for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n    const column = columns[colIdx];\n\n    if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n    viewportColumns.push(column);\n  }\n\n  return viewportColumns;\n}\n"]}