{"version":3,"file":"selectedCellUtils.js","sourceRoot":"","sources":["../../src/utils/selectedCellUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellNavigationMode } from '../common/enums';\nimport { canEdit } from './columnUtils';\nimport { CalculatedColumn, Position, Range, Dimension } from '../common/types';\n\nconst zCellMask = 1;\nconst zFrozenCellMask = 3;\n\ninterface GetSelectedDimensionsOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowHeight: number;\n  scrollLeft: number;\n}\n\nexport function getSelectedDimensions<R, SR>({ selectedPosition: { idx, rowIdx }, columns, rowHeight, scrollLeft }: GetSelectedDimensionsOpts<R, SR>): Dimension {\n  if (idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: 1 };\n  }\n  const column = columns[idx];\n  const { width } = column;\n  const left = column.frozen ? column.left + scrollLeft : column.left;\n  const top = rowIdx * rowHeight;\n  const zIndex = column.frozen ? zFrozenCellMask : zCellMask;\n  return { width, left, top, height: rowHeight, zIndex };\n}\n\ninterface GetSelectedRangeDimensionsOpts<R, SR> {\n  selectedRange: Range;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowHeight: number;\n}\n\nexport function getSelectedRangeDimensions<R, SR>({ selectedRange: { topLeft, bottomRight }, columns, rowHeight }: GetSelectedRangeDimensionsOpts<R, SR>): Dimension {\n  if (topLeft.idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: zCellMask };\n  }\n\n  let width = 0;\n  let anyColFrozen = false;\n  for (let i = topLeft.idx; i <= bottomRight.idx; i++) {\n    const column = columns[i];\n    width += column.width;\n    if (column.frozen) anyColFrozen = true;\n  }\n\n  const { left } = columns[topLeft.idx];\n  const top = topLeft.rowIdx * rowHeight;\n  const height = (bottomRight.rowIdx - topLeft.rowIdx + 1) * rowHeight;\n  const zIndex = anyColFrozen ? zFrozenCellMask : zCellMask;\n\n  return { width, left, top, height, zIndex };\n}\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly R[];\n  onCheckCellIsEditable?: (arg: { row: R; column: CalculatedColumn<R, SR> } & Position) => boolean;\n}\n\nexport function isSelectedCellEditable<R, SR>({ selectedPosition, columns, rows, onCheckCellIsEditable }: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit<R, SR>(column, row);\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n}\n\nexport function canExitGrid<R, SR>(event: React.KeyboardEvent, { cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx } }: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    const shift = event.shiftKey === true;\n\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nexport function selectedRangeIsSingleCell({ topLeft, bottomRight }: Range): boolean {\n  return topLeft.idx === bottomRight.idx && topLeft.rowIdx === bottomRight.rowIdx;\n}\n"]}